%% SIMULATED ANNEALING

% This algorithm is an implementation of simulated annealing with a constraint
% on the generation of points. New generated points for candidate designs
% are within a predefinied neighbourhood of some random subset of points from the
% previous design. This is to test if an exact design can be further
% optimized by replacing some of the support points with nearby points.


rng(123); % set seed for reproducability

%% INITIALIZE DESIGN WITH CVX
tic

dim = 5;
N0 = 4; % number of initial design points (N0^dim)

% design space bounds
a1 = -1; b1 = 1;

A = [a1 a1 a1 a1 a1]; % array of bounds for get_neighbour function
B =[b1 b1 b1 b1 b1];

%x = setprod(linspace(a1,b1,N0),linspace(a1,b1,N0),linspace(a1,b1,N0));
% design space generated by a cartesian product
x = setprod(linspace(a1,b1,N0),linspace(a1,b1,N0),linspace(a1,b1,N0),linspace(a1,b1,N0),linspace(a1,b1,N0));


% Compute components of FIM
theta = [1 1 1 1 1 1 1 1];


I0 = FIM_1d_saturated_cubic(x); 
q = size(I0,1);

% INITIALIZE DESIGN

sc = 1;
tol = 1e-4;
cvx_begin
            cvx_precision high
            variable w(1,N0^dim); %weights
            expression Ie(q,q); %information matrix
            
            for i=1:N0^dim
                Ie = Ie+I0(:,:,i)*w(i);
            end
           
            Ie=sc*Ie;

            minimize(-log(det_rootn(Ie)))   %D-opt

            0 <= w <= 1;
            sum(w)==1;
cvx_end

%initialize weights, optimal design, and objective function value
d = x(w(1,:)>tol,:);
w = w(w(1,:)>tol)'; 
L = cvx_optval;

% get copy of design for annealing
d0 = d(:,:); 
w0 = w(:,:);
%% INITIALIZE ANNEALING PARAMETERS


N = 20; % number of points allowed in exact design

c0 = 4; % max number of points replaced per iteration

Nt = 1500; % number of iterations per temperature change

T0 = 0.0001; % initial temperature

M0 = 80; % number of temperature changes before algorithm terminates

alpha = 0.9; % cooling rate

Tmin = T0*alpha^M0; % minimum temperature before annealing stops

delta =  0.5; % size of neighbourhood of randomly generated points


w0 = initializeExact(w,N); % convert approximate design lazily to exact design
w = initializeExact(w,N);
% weights are adjusted such that N*w0 gives exact design

k = length(w0); 

% Initialize loss of exact design
FIM = FIM_1dpolyreg(d0);
FIM = sum(FIM.*reshape(w0,1,1,[]),3);

   

L0 = -log(det(FIM)^(1/q));

% store loss at each iteration for plotting
loss = zeros(1,M0*Nt);
loss(1) = L0;
L = loss(1);

%% BEGIN ALGORITHM

num_iters = 1;
T = T0;
while(T > Tmin)

    % GENERATING RANDOM CANDIDATE DESIGN
    for h = 1:Nt
        
        k = length(w0); % current number of support points
        ci =  randi([1 c0]); % number of points to be replaced
        toRemove = randperm(k,ci); % randomly select ci points to remove
        
        % creating new candidate design
        wi = zeros(k+ci,1); 
        di = zeros(k+ci,dim);
        
        % copy previous design
        wi(1:k) = w0(:);
        di(1:k,:) = d0(:,:);
        
       
        % remove selected points
        for j = toRemove
            wi(j) = wi(j) - 1/N; 
        end
    
        % add weight for new points
        for j = 1:ci
            wi(k+j) = wi(k+j) + 1/N; 
        end
        
        % generate new points in neighbourhood of those previously removed
        i = ci;
        for j = toRemove
                di_nb = get_neighbour(di(j,:),delta,A,B);
                di(k+i,:) = di_nb;
                i = i + 1; 
        end
        % points are generated in a circular, spherical, or hyperspherical
        % region (depending on the dimension of the design) of radius
        % delta
        
        % remove support points with zero weight
        di = di(wi>0,:);
        wi = wi(wi>0);
        
        % compute loss of candidate design
        FIMi = FIM_1dpolyreg(di);
        FIMi = sum(FIMi.*reshape(wi,1,1,[]),3);
        Li = -log(det(FIMi)^(1/q));
   
   % PROCEED WITH ANNEALING STEP

    prob = exp(-(Li-L0)/T); % acceptance probability

    if prob > rand(1) % criterion for accepting random design
        L0 = Li;
        d0 = di;
        w0 = wi;
    end
    num_iters = num_iters+1;
    loss(num_iters) = L0;
    end

    T = alpha*T;
end
toc
