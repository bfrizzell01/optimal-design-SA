% Implementing a simulated annealing algorithm to generate exact designs
% from an approximate design of any generalized linear model

rng(123); % set seed for reproducability
%% INITIALIZE DESIGN WITH CVX

dim = 1;
N0 = 21; % number of initial design points (N0^dim)

% design space bounds
a1 = -1; b1 = 1;
%a2 = 0; b2 = 1;
%a3 = 0; b3 = 1;

%A = [a1 a2 a3];
%B = [b1 b2 b3];

A = [a1];
B =[b1];

%x = setprod(linspace(a1,b1,N0),linspace(a2,b2,N0),linspace(a3,b3,N0));
% design space generated by a cartesian product
x = linspace(a1,b1,N0)';


% Compute components of FIM
theta = [1 1 1 1 1 1 1 1];


I0 = FIM_1dpolyreg(x); 
q = size(I0,1);

% INITIALIZE DESIGN

sc = 1;
tol = 1e-4;
cvx_begin
            cvx_precision high
            variable w(1,N0^dim); %weights
            expression Ie(q,q); %information matrix
            
            for i=1:N0^dim
                Ie = Ie+I0(:,:,i)*w(i);
            end
           
            Ie=sc*Ie;

            minimize(-log(det_rootn(Ie)))   %D-opt

            0 <= w <= 1;
            sum(w)==1;
cvx_end

%initialize weights, optimal design, and objective function value
d = x(w(1,:)>tol,:);
w = w(w(1,:)>tol)'; 
L = cvx_optval;

% get copy of design for annealing
d0 = d(:,:); 
w0 = w(:,:);

%% EXACT DESIGN IMPLEMENTATION


N = 20; % number of points allowed in exact design

c0 = 4; % max number of points replaced per iteration

Nt = 1500; % number of iterations per temperature change

T0 = 0.0001; % initial temperature

M0 = 80; % number of temperature changes before algorithm terminates

alpha = 0.9; % cooling rate

Tmin = T0*alpha^M0; % minimum temperature before annealing stops

delta =  0.5; % size of neighbourhood of randomly generated points


w0 = initializeExact(w,N); % convert approximate design lazily to exact design
w = initializeExact(w,N);
% weights are adjusted such that N*w0 gives exact design

k = length(w0); 

% Initialize loss of exact design
FIM = FIM_1dpolyreg(d0);
FIM = sum(FIM.*reshape(w0,1,1,[]),3);

   

L0 = -log(det(FIM)^(1/q));

% store loss at each iteration for plotting
loss = zeros(1,M0*Nt);
loss(1) = L0;
L = loss(1);

%% ANNEALING ALGORITTHM

% This algorithm is an implementation of simulated annealing with a constraint
% on the generation of points. New generated points for candidate designs
% are within a predefinied neighbourhood of some random subset of points from the
% previous design. This is to test if an exact design can be further
% optimized by replacing some of the support points with nearby points.

num_iters = 1;
T = T0;
while(T > Tmin)

    % GENERATING RANDOM CANDIDATE DESIGN
    for h = 1:Nt
        
        k = length(w0); % current number of support points
        ci =  randi([1 c0]); % number of points to be replaced
        toRemove = randperm(k,ci); % randomly select ci points to remove
        
        % creating new candidate design
        wi = zeros(k+ci,1); 
        di = zeros(k+ci,dim);
        
        % copy previous design
        wi(1:k) = w0(:);
        di(1:k,:) = d0(:,:);
        
       
        % remove selected points
        for j = toRemove
            wi(j) = wi(j) - 1/N; 
        end
    
        % add weight for new points
        for j = 1:ci
            wi(k+j) = wi(k+j) + 1/N; 
        end
        
        % generate new points in neighbourhood of those previously removed
        i = ci;
        for j = toRemove
                di_nb = get_neighbour(di(j,:),delta,A,B);
                di(k+i,:) = di_nb;
                i = i + 1; 
        end
        % points are generated in a circular, spherical, or hyperspherical
        % region (depending on the dimension of the design) of radius
        % delta
        
        % remove support points with zero weight
        di = di(wi>0,:);
        wi = wi(wi>0);
        
        % compute loss of candidate design
        FIMi = FIM_1dpolyreg(di);
        FIMi = sum(FIMi.*reshape(wi,1,1,[]),3);
        Li = -log(det(FIMi)^(1/q));
   
   % PROCEED WITH ANNEALING STEP

    prob = exp(-(Li-L0)/T); % acceptance probability

    if prob > rand(1) % criterion for accepting random design
        L0 = Li;
        d0 = di;
        w0 = wi;
    end
    num_iters = num_iters+1;
    loss(num_iters) = L0;
    end

    T = alpha*T;
end


%% PLOTTING RESULTS

% Plot loss
figure;
plot(1:length(loss),loss);
xlabel("Iteration");
ylabel("Loss");
title("Annealing Schedule");
textbox_str = {sprintf('N = %d', N), sprintf('T0 =  %.d', T0),sprintf('M0 = %d', M0),sprintf('Nt = %d', Nt),sprintf('c0 = %d', c0),sprintf('delta = %.2f', delta)};
textbox = annotation('textbox', [0.75, 0.7, 0.2, 0.1], 'String', textbox_str, 'FitBoxToText', 'on', 'EdgeColor', 'none', 'BackgroundColor', 'white');

% Plot initial and final design
figure;
plt1 = scatter3(d0(:,1),d0(:,2),d0(:,3),"filled", "red",'MarkerFaceAlpha', 0.5,'MarkerEdgeColor', 'black');
title("Final Exact Design");
xlabel("x1");
ylabel("x2");
zlabel("x3");
grid on;

figure;
plt2 = scatter3(d(:,1),d(:,2),d(:,3),"filled", "blue",'MarkerFaceAlpha', 0.5);
title("Initial Exact Design");
xlabel("x1");
ylabel("x2");
zlabel("x3");
grid on

%legend([plt1,plt2], ["Final Design", "Initial Design"])




%NOTES

% organize weights
[w0,d0] = bincount(w0,d0);

disp("INITIAL DESIGN")
[N*w d]
disp("FINAL DESIGN")
[N*w0 d0]

if L < L0
    disp("INITIAL DESIGN SUPERIOR")
else
    disp("FINAL DESIGN SUPERIOR")
end

% multiple plots for initial and final design
% change initializeExact, try randomized rounding
% 

%% PLOT FOR 1D

[w0,d0] = bincount(w0,d0);

figure;
plt1 = scatter(d0,N*w0,"filled", "red",'MarkerFaceAlpha', 0.5,'MarkerEdgeColor', 'black');
title("Final Exact Design");
xlabel("x");
ylabel("weight");
grid on

figure;
plt1 = scatter(d,N*w,"filled", "blue",'MarkerFaceAlpha', 0.5,'MarkerEdgeColor', 'black');
title("Initial Exact Design");
xlabel("x");
ylabel("weight");
grid on

figure;
plot(1:length(loss),loss);
xlabel("Iteration");
ylabel("Loss");
title("Annealing Schedule");
textbox_str = {sprintf('N = %d', N), sprintf('T0 =  %.d', T0),sprintf('M0 = %d', M0),sprintf('Nt = %d', Nt),sprintf('c0 = %d', c0),sprintf('delta = %.2f', delta)};
textbox = annotation('textbox', [0.75, 0.7, 0.2, 0.1], 'String', textbox_str, 'FitBoxToText', 'on', 'EdgeColor', 'none', 'BackgroundColor', 'white');



% organize weights

disp("INITIAL DESIGN")
[N*w d]
disp("FINAL DESIGN")
[N*w0 d0]

if L < L0
    disp("INITIAL DESIGN SUPERIOR")
else
    disp("FINAL DESIGN SUPERIOR")
end

% multiple plots for initial and final design
% change initializeExact, try randomized rounding
% 
